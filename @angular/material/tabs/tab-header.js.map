{"version":3,"sources":["../../../src/lib/tabs/tab-header.ts"],"names":[],"mappings":"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","file":"tab-header.js","sourcesContent":["import {\r\n  ViewChild,\r\n  Component,\r\n  Input,\r\n  NgZone,\r\n  QueryList,\r\n  ElementRef,\r\n  ViewEncapsulation,\r\n  ContentChildren,\r\n  Output,\r\n  EventEmitter,\r\n  Optional,\r\n  AfterContentChecked,\r\n  AfterContentInit,\r\n} from '@angular/core';\r\nimport {RIGHT_ARROW, LEFT_ARROW, ENTER, Dir, LayoutDirection} from '../core';\r\nimport {MdTabLabelWrapper} from './tab-label-wrapper';\r\nimport {MdInkBar} from './ink-bar';\r\nimport 'rxjs/add/operator/map';\r\nimport {applyCssTransform} from '../core/style/apply-transform';\r\n\r\n/**\r\n * The directions that scrolling can go in when the header's tabs exceed the header width. 'After'\r\n * will scroll the header towards the end of the tabs list and 'before' will scroll towards the\r\n * beginning of the list.\r\n */\r\nexport type ScrollDirection = 'after' | 'before';\r\n\r\n/**\r\n * The distance in pixels that will be overshot when scrolling a tab label into view. This helps\r\n * provide a small affordance to the label next to it.\r\n */\r\nconst EXAGGERATED_OVERSCROLL = 60;\r\n\r\n/**\r\n * The header of the tab group which displays a list of all the tabs in the tab group. Includes\r\n * an ink bar that follows the currently selected tab. When the tabs list's width exceeds the\r\n * width of the header container, then arrows will be displayed to allow the user to scroll\r\n * left and right across the header.\r\n */\r\n@Component({\r\n  moduleId: module.id,\r\n  selector: 'md-tab-header',\r\n  templateUrl: 'tab-header.html',\r\n  styleUrls: ['tab-header.css'],\r\n  encapsulation: ViewEncapsulation.None,\r\n  host: {\r\n    'class': 'md-tab-header',\r\n    '[class.md-tab-header-pagination-controls-enabled]': '_showPaginationControls',\r\n    '[class.md-tab-header-rtl]': \"_getLayoutDirection() == 'rtl'\",\r\n  }\r\n})\r\nexport class MdTabHeader implements AfterContentChecked, AfterContentInit {\r\n  @ContentChildren(MdTabLabelWrapper) _labelWrappers: QueryList<MdTabLabelWrapper>;\r\n\r\n  @ViewChild(MdInkBar) _inkBar: MdInkBar;\r\n  @ViewChild('tabListContainer') _tabListContainer: ElementRef;\r\n  @ViewChild('tabList') _tabList: ElementRef;\r\n\r\n  /** The tab index that is focused. */\r\n  private _focusIndex: number = 0;\r\n\r\n  /** The distance in pixels that the tab labels should be translated to the left. */\r\n  private _scrollDistance = 0;\r\n\r\n  /** Whether the header should scroll to the selected index after the view has been checked. */\r\n  private _selectedIndexChanged = false;\r\n\r\n  /** Whether the controls for pagination should be displayed */\r\n  _showPaginationControls = false;\r\n\r\n  /** Whether the tab list can be scrolled more towards the end of the tab label list. */\r\n  _disableScrollAfter = true;\r\n\r\n  /** Whether the tab list can be scrolled more towards the beginning of the tab label list. */\r\n  _disableScrollBefore = true;\r\n\r\n  /**\r\n   * The number of tab labels that are displayed on the header. When this changes, the header\r\n   * should re-evaluate the scroll position.\r\n   */\r\n  private _tabLabelCount: number;\r\n\r\n  /** Whether the scroll distance has changed and should be applied after the view is checked. */\r\n  private _scrollDistanceChanged: boolean;\r\n\r\n  private _selectedIndex: number = 0;\r\n\r\n  /** The index of the active tab. */\r\n  @Input() set selectedIndex(value: number) {\r\n    this._selectedIndexChanged = this._selectedIndex != value;\r\n\r\n    this._selectedIndex = value;\r\n    this._focusIndex = value;\r\n  }\r\n  get selectedIndex(): number { return this._selectedIndex; }\r\n\r\n  /** Event emitted when the option is selected. */\r\n  @Output() selectFocusedIndex = new EventEmitter();\r\n\r\n  /** Event emitted when a label is focused. */\r\n  @Output() indexFocused = new EventEmitter();\r\n\r\n  constructor(private _zone: NgZone,\r\n              private _elementRef: ElementRef,\r\n              @Optional() private _dir: Dir) {}\r\n\r\n  ngAfterContentChecked(): void {\r\n    // If the number of tab labels have changed, check if scrolling should be enabled\r\n    if (this._tabLabelCount != this._labelWrappers.length) {\r\n      this._updatePagination();\r\n      this._tabLabelCount = this._labelWrappers.length;\r\n    }\r\n\r\n    // If the selected index has changed, scroll to the label and check if the scrolling controls\r\n    // should be disabled.\r\n    if (this._selectedIndexChanged) {\r\n      this._scrollToLabel(this._selectedIndex);\r\n      this._checkScrollingControls();\r\n      this._alignInkBarToSelectedTab();\r\n      this._selectedIndexChanged = false;\r\n    }\r\n\r\n    // If the scroll distance has been changed (tab selected, focused, scroll controls activated),\r\n    // then translate the header to reflect this.\r\n    if (this._scrollDistanceChanged) {\r\n      this._updateTabScrollPosition();\r\n      this._scrollDistanceChanged = false;\r\n    }\r\n  }\r\n\r\n  _handleKeydown(event: KeyboardEvent) {\r\n    switch (event.keyCode) {\r\n      case RIGHT_ARROW:\r\n        this._focusNextTab();\r\n        break;\r\n      case LEFT_ARROW:\r\n        this._focusPreviousTab();\r\n        break;\r\n      case ENTER:\r\n        this.selectFocusedIndex.emit(this.focusIndex);\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Aligns the ink bar to the selected tab on load.\r\n   */\r\n  ngAfterContentInit() {\r\n    this._alignInkBarToSelectedTab();\r\n  }\r\n\r\n  /**\r\n   * Callback for when the MutationObserver detects that the content has changed.\r\n   */\r\n  _onContentChanges() {\r\n    this._updatePagination();\r\n    this._alignInkBarToSelectedTab();\r\n  }\r\n\r\n  /**\r\n   * Updating the view whether pagination should be enabled or not\r\n   */\r\n  _updatePagination() {\r\n    this._checkPaginationEnabled();\r\n    this._checkScrollingControls();\r\n    this._updateTabScrollPosition();\r\n  }\r\n\r\n  /** When the focus index is set, we must manually send focus to the correct label */\r\n  set focusIndex(value: number) {\r\n    if (!this._isValidIndex(value) || this._focusIndex == value) { return; }\r\n\r\n    this._focusIndex = value;\r\n    this.indexFocused.emit(value);\r\n\r\n    this._setTabFocus(value);\r\n  }\r\n\r\n  /** Tracks which element has focus; used for keyboard navigation */\r\n  get focusIndex(): number { return this._focusIndex; }\r\n\r\n  /**\r\n   * Determines if an index is valid.  If the tabs are not ready yet, we assume that the user is\r\n   * providing a valid index and return true.\r\n   */\r\n  _isValidIndex(index: number): boolean {\r\n    if (!this._labelWrappers) { return true; }\r\n\r\n    const tab = this._labelWrappers ? this._labelWrappers.toArray()[index] : null;\r\n    return tab && !tab.disabled;\r\n  }\r\n\r\n  /**\r\n   * Sets focus on the HTML element for the label wrapper and scrolls it into the view if\r\n   * scrolling is enabled.\r\n   */\r\n  _setTabFocus(tabIndex: number) {\r\n    if (this._showPaginationControls) {\r\n      this._scrollToLabel(tabIndex);\r\n    }\r\n\r\n    if (this._labelWrappers && this._labelWrappers.length) {\r\n      this._labelWrappers.toArray()[tabIndex].focus();\r\n\r\n      // Do not let the browser manage scrolling to focus the element, this will be handled\r\n      // by using translation. In LTR, the scroll left should be 0. In RTL, the scroll width\r\n      // should be the full width minus the offset width.\r\n      const containerEl = this._tabListContainer.nativeElement;\r\n      const dir = this._getLayoutDirection();\r\n      if (dir == 'ltr') {\r\n        containerEl.scrollLeft = 0;\r\n      } else {\r\n        containerEl.scrollLeft = containerEl.scrollWidth - containerEl.offsetWidth;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Moves the focus towards the beginning or the end of the list depending on the offset provided.\r\n   * Valid offsets are 1 and -1.\r\n   */\r\n  _moveFocus(offset: number) {\r\n    if (this._labelWrappers) {\r\n      const tabs: MdTabLabelWrapper[] = this._labelWrappers.toArray();\r\n      for (let i = this.focusIndex + offset; i < tabs.length && i >= 0; i += offset) {\r\n        if (this._isValidIndex(i)) {\r\n          this.focusIndex = i;\r\n          return;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Increment the focus index by 1 until a valid tab is found. */\r\n  _focusNextTab(): void {\r\n    this._moveFocus(this._getLayoutDirection() == 'ltr' ? 1 : -1);\r\n  }\r\n\r\n  /** Decrement the focus index by 1 until a valid tab is found. */\r\n  _focusPreviousTab(): void {\r\n    this._moveFocus(this._getLayoutDirection() == 'ltr' ? -1 : 1);\r\n  }\r\n\r\n  /** The layout direction of the containing app. */\r\n  _getLayoutDirection(): LayoutDirection {\r\n    return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\r\n  }\r\n\r\n  /** Performs the CSS transformation on the tab list that will cause the list to scroll. */\r\n  _updateTabScrollPosition() {\r\n    let translateX = this.scrollDistance + 'px';\r\n    if (this._getLayoutDirection() == 'ltr') {\r\n      translateX = '-' + translateX;\r\n    }\r\n\r\n    applyCssTransform(this._tabList.nativeElement, `translate3d(${translateX}, 0, 0)`);\r\n  }\r\n\r\n  /** Sets the distance in pixels that the tab header should be transformed in the X-axis. */\r\n  set scrollDistance(v: number) {\r\n    this._scrollDistance = Math.max(0, Math.min(this._getMaxScrollDistance(), v));\r\n\r\n    // Mark that the scroll distance has changed so that after the view is checked, the CSS\r\n    // transformation can move the header.\r\n    this._scrollDistanceChanged = true;\r\n\r\n    this._checkScrollingControls();\r\n  }\r\n  get scrollDistance(): number { return this._scrollDistance;  }\r\n\r\n  /**\r\n   * Moves the tab list in the 'before' or 'after' direction (towards the beginning of the list or\r\n   * the end of the list, respectively). The distance to scroll is computed to be a third of the\r\n   * length of the tab list view window.\r\n   *\r\n   * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\r\n   * should be called sparingly.\r\n   */\r\n  _scrollHeader(scrollDir: ScrollDirection) {\r\n    const viewLength = this._tabListContainer.nativeElement.offsetWidth;\r\n\r\n    // Move the scroll distance one-third the length of the tab list's viewport.\r\n    this.scrollDistance += (scrollDir == 'before' ? -1 : 1) * viewLength / 3;\r\n  }\r\n\r\n  /**\r\n   * Moves the tab list such that the desired tab label (marked by index) is moved into view.\r\n   *\r\n   * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\r\n   * should be called sparingly.\r\n   */\r\n  _scrollToLabel(labelIndex: number) {\r\n    const selectedLabel = this._labelWrappers\r\n        ? this._labelWrappers.toArray()[labelIndex]\r\n        :  null;\r\n\r\n    if (!selectedLabel) { return; }\r\n\r\n    // The view length is the visible width of the tab labels.\r\n    const viewLength = this._tabListContainer.nativeElement.offsetWidth;\r\n\r\n    let labelBeforePos: number, labelAfterPos: number;\r\n    if (this._getLayoutDirection() == 'ltr') {\r\n      labelBeforePos = selectedLabel.getOffsetLeft();\r\n      labelAfterPos = labelBeforePos + selectedLabel.getOffsetWidth();\r\n    } else {\r\n      labelAfterPos = this._tabList.nativeElement.offsetWidth - selectedLabel.getOffsetLeft();\r\n      labelBeforePos = labelAfterPos - selectedLabel.getOffsetWidth();\r\n    }\r\n\r\n    const beforeVisiblePos = this.scrollDistance;\r\n    const afterVisiblePos = this.scrollDistance + viewLength;\r\n\r\n    if (labelBeforePos < beforeVisiblePos) {\r\n      // Scroll header to move label to the before direction\r\n      this.scrollDistance -= beforeVisiblePos - labelBeforePos + EXAGGERATED_OVERSCROLL;\r\n    } else if (labelAfterPos > afterVisiblePos) {\r\n      // Scroll header to move label to the after direction\r\n      this.scrollDistance += labelAfterPos - afterVisiblePos + EXAGGERATED_OVERSCROLL;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Evaluate whether the pagination controls should be displayed. If the scroll width of the\r\n   * tab list is wider than the size of the header container, then the pagination controls should\r\n   * be shown.\r\n   *\r\n   * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\r\n   * should be called sparingly.\r\n   */\r\n  _checkPaginationEnabled() {\r\n    this._showPaginationControls =\r\n        this._tabList.nativeElement.scrollWidth > this._elementRef.nativeElement.offsetWidth;\r\n\r\n    if (!this._showPaginationControls) {\r\n      this.scrollDistance = 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Evaluate whether the before and after controls should be enabled or disabled.\r\n   * If the header is at the beginning of the list (scroll distance is equal to 0) then disable the\r\n   * before button. If the header is at the end of the list (scroll distance is equal to the\r\n   * maximum distance we can scroll), then disable the after button.\r\n   *\r\n   * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\r\n   * should be called sparingly.\r\n   */\r\n  _checkScrollingControls() {\r\n    // Check if the pagination arrows should be activated.\r\n    this._disableScrollBefore = this.scrollDistance == 0;\r\n    this._disableScrollAfter = this.scrollDistance == this._getMaxScrollDistance();\r\n  }\r\n\r\n  /**\r\n   * Determines what is the maximum length in pixels that can be set for the scroll distance. This\r\n   * is equal to the difference in width between the tab list container and tab header container.\r\n   *\r\n   * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\r\n   * should be called sparingly.\r\n   */\r\n  _getMaxScrollDistance(): number {\r\n    const lengthOfTabList = this._tabList.nativeElement.scrollWidth;\r\n    const viewLength = this._tabListContainer.nativeElement.offsetWidth;\r\n    return lengthOfTabList - viewLength;\r\n  }\r\n\r\n  /** Tells the ink-bar to align itself to the current label wrapper */\r\n  private _alignInkBarToSelectedTab(): void {\r\n    const selectedLabelWrapper = this._labelWrappers && this._labelWrappers.length\r\n        ? this._labelWrappers.toArray()[this.selectedIndex].elementRef.nativeElement\r\n        : null;\r\n\r\n    this._zone.runOutsideAngular(() => {\r\n      requestAnimationFrame(() => {\r\n        this._inkBar.alignToElement(selectedLabelWrapper);\r\n      });\r\n    });\r\n  }\r\n}\r\n"]}
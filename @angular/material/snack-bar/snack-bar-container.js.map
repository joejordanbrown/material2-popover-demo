{"version":3,"sources":["../../../src/lib/snack-bar/snack-bar-container.ts"],"names":[],"mappings":"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","file":"snack-bar-container.js","sourcesContent":["import {\r\n  Component,\r\n  ComponentRef,\r\n  ViewChild,\r\n  trigger,\r\n  state,\r\n  style,\r\n  transition,\r\n  animate,\r\n  AnimationTransitionEvent,\r\n  NgZone,\r\n  OnDestroy,\r\n} from '@angular/core';\r\nimport {\r\n  BasePortalHost,\r\n  ComponentPortal,\r\n  TemplatePortal,\r\n  PortalHostDirective,\r\n} from '../core';\r\nimport {MdSnackBarConfig} from './snack-bar-config';\r\nimport {MdSnackBarContentAlreadyAttached} from './snack-bar-errors';\r\nimport {Observable} from 'rxjs/Observable';\r\nimport {Subject} from 'rxjs/Subject';\r\n\r\n\r\n\r\nexport type SnackBarState = 'initial' | 'visible' | 'complete' | 'void';\r\n\r\n// TODO(jelbourn): we can't use constants from animation.ts here because you can't use\r\n// a text interpolation in anything that is analyzed statically with ngc (for AoT compile).\r\nexport const SHOW_ANIMATION = '225ms cubic-bezier(0.4,0.0,1,1)';\r\nexport const HIDE_ANIMATION = '195ms cubic-bezier(0.0,0.0,0.2,1)';\r\n\r\n/**\r\n * Internal component that wraps user-provided snack bar content.\r\n * @docs-private\r\n */\r\n@Component({\r\n  moduleId: module.id,\r\n  selector: 'snack-bar-container',\r\n  templateUrl: 'snack-bar-container.html',\r\n  styleUrls: ['snack-bar-container.css'],\r\n  host: {\r\n    'role': 'alert',\r\n    '[@state]': 'animationState',\r\n    '(@state.done)': 'onAnimationEnd($event)'\r\n  },\r\n  animations: [\r\n    trigger('state', [\r\n      state('initial', style({transform: 'translateY(100%)'})),\r\n      state('visible', style({transform: 'translateY(0%)'})),\r\n      state('complete', style({transform: 'translateY(100%)'})),\r\n      transition('visible => complete', animate(HIDE_ANIMATION)),\r\n      transition('initial => visible, void => visible', animate(SHOW_ANIMATION)),\r\n    ])\r\n  ],\r\n})\r\nexport class MdSnackBarContainer extends BasePortalHost implements OnDestroy {\r\n  /** The portal host inside of this container into which the snack bar content will be loaded. */\r\n  @ViewChild(PortalHostDirective) _portalHost: PortalHostDirective;\r\n\r\n  /** Subject for notifying that the snack bar has exited from view. */\r\n  private onExit: Subject<any> = new Subject();\r\n\r\n  /** Subject for notifying that the snack bar has finished entering the view. */\r\n  private onEnter: Subject<any> = new Subject();\r\n\r\n  /** The state of the snack bar animations. */\r\n  animationState: SnackBarState = 'initial';\r\n\r\n  /** The snack bar configuration. */\r\n  snackBarConfig: MdSnackBarConfig;\r\n\r\n  constructor(private _ngZone: NgZone) {\r\n    super();\r\n  }\r\n\r\n  /** Attach a component portal as content to this snack bar container. */\r\n  attachComponentPortal<T>(portal: ComponentPortal<T>): ComponentRef<T> {\r\n    if (this._portalHost.hasAttached()) {\r\n      throw new MdSnackBarContentAlreadyAttached();\r\n    }\r\n\r\n    return this._portalHost.attachComponentPortal(portal);\r\n  }\r\n\r\n  /** Attach a template portal as content to this snack bar container. */\r\n  attachTemplatePortal(portal: TemplatePortal): Map<string, any> {\r\n    throw Error('Not yet implemented');\r\n  }\r\n\r\n  /** Handle end of animations, updating the state of the snackbar. */\r\n  onAnimationEnd(event: AnimationTransitionEvent) {\r\n    if (event.toState === 'void' || event.toState === 'complete') {\r\n      this._completeExit();\r\n    }\r\n\r\n    if (event.toState === 'visible') {\r\n      this._ngZone.run(() => {\r\n        this.onEnter.next();\r\n        this.onEnter.complete();\r\n      });\r\n    }\r\n  }\r\n\r\n  /** Begin animation of snack bar entrance into view. */\r\n  enter(): void {\r\n    this.animationState = 'visible';\r\n  }\r\n\r\n  /** Returns an observable resolving when the enter animation completes.  */\r\n  _onEnter(): Observable<void> {\r\n    this.animationState = 'visible';\r\n    return this.onEnter.asObservable();\r\n  }\r\n\r\n  /** Begin animation of the snack bar exiting from view. */\r\n  exit(): Observable<void> {\r\n    this.animationState = 'complete';\r\n    return this._onExit();\r\n  }\r\n\r\n  /** Returns an observable that completes after the closing animation is done. */\r\n  _onExit(): Observable<void> {\r\n    return this.onExit.asObservable();\r\n  }\r\n\r\n  /**\r\n   * Makes sure the exit callbacks have been invoked when the element is destroyed.\r\n   */\r\n  ngOnDestroy() {\r\n    this._completeExit();\r\n  }\r\n\r\n  /**\r\n   * Waits for the zone to settle before removing the element. Helps prevent\r\n   * errors where we end up removing an element which is in the middle of an animation.\r\n   */\r\n  private _completeExit() {\r\n    this._ngZone.onMicrotaskEmpty.first().subscribe(() => {\r\n      this.onExit.next();\r\n      this.onExit.complete();\r\n    });\r\n  }\r\n}\r\n"]}